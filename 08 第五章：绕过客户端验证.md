# 第五章：绕过客户端验证

第一章描述了Web应用程序的核心安全问题，由于客户端可以提交任意输入，因此该问题出现了。尽管如此，许多Web应用程序仍然依赖于各种在客户端实现的措施来控制提交给服务器的数据。通常，这代表了一个基本的安全缺陷：用户对客户端和提交的数据具有完全控制权，并且可以绕过在客户端上实现的任何控件，并且这些控件不会在服务器上复制。

应用程序可能以两种广泛的方式依赖于客户端控件来限制用户输入。首先，应用程序可以使用它假定可以防止用户在应用程序稍后读取时修改该数据的机制，通过客户端组件传输数据。其次，应用程序可以在客户端上实现控制用户与其自身客户端交互的措施，或在提交之前围绕用户输入应用控件以限制功能。这可以使用HTML表单功能，客户端脚本或浏览器扩展技术来实现。

本章研究了每种客户端控件的示例，并描述了可以绕过它们的方法。

## 通过客户端传输数据

通常会看到应用程序以最终用户无法直接查看或修改的形式将数据传递给客户端，并期望该数据将在后续请求中发送回服务器。通常，应用程序的开发人员只是假设所使用的传输机制将确保通过客户端传输的数据不会被修改。

因为从客户端提交到服务器的所有内容都在用户的控制范围内，所以假设通过客户端传输的数据不会被修改通常是错误的，并且经常使应用程序容易受到一种或多种攻击。

您可能会合理地想知道，如果服务器知道并指定了特定数据项，应用程序为什么还需要将此值传输到客户端然后将其读回。实际上，以这种方式编写应用程序对于开发人员来说通常更容易，原因如下：

- 它消除了跟踪用户会话中所有类型数据的需要。减少在服务器上存储的会话数据量还可以提高应用程序的性能。
- 如果应用程序部署在多个不同的服务器上，并且用户可能与多个服务器交互以执行多步骤操作，则在可能处理同一用户请求的主机之间共享服务器端数据可能并不简单。使用客户端传输数据可能是解决该问题的诱人解决方案。
- 如果应用程序在服务器上使用任何第三方组件，例如购物车，则修改这些组件可能很困难或不可能，因此通过客户端传输数据可能是集成的最简单方法。
- 在某些情况下，跟踪服务器上的新数据可能需要更新核心服务器端API，从而触发完整的正式变更管理过程和回归测试。实施涉及客户端数据传输的更零散的解决方案可以避免这种情况，从而实现紧迫的期限。

但是，以这种方式传输敏感数据通常是不安全的，并且是应用程序中无数漏洞的原因。

## 隐藏表单字段

隐藏的HTML表单字段是一种通过客户端以表面上不可修改的方式传输数据的常用机制。如果字段被标记为隐藏，则不会在屏幕上显示。但是，字段的名称和值存储在表单中，并在用户提交表单时发送回应用程序。

这个安全缺陷的典型示例是零售应用程序，该应用程序将产品价格存储在隐藏的表单字段中。在Web应用程序的早期，这种漏洞非常普遍，并且今天仍然存在。图5-1显示了一个典型的表单。

![](./img/101201.jpg)

图5-1：传统的HTML表单

表单的代码如下所示：

```html
<form method=”post” action=”Shop.aspx?prod=1”>
Product: iPhone 5 <br/>
Price: 449 <br/>
Quantity: <input type=”text” name=”quantity”> (Maximum quantity is 50)
<br/>
<input type=”hidden” name=”price” value=”449”>
<input type=”submit” value=”Buy”>
</form>
```

请注意名为price的表单字段，该字段被标记为隐藏。当用户提交表单时，此字段将发送到服务器：

```http
POST /shop/28/Shop.aspx?prod=1 HTTP/1.1
Host: mdsec.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 20
quantity=1&price=449
```

尽管价格字段未显示在屏幕上，并且用户无法编辑它，但这完全是因为应用程序已指示浏览器隐藏该字段。因为客户端发生的一切最终都在用户的控制范围内，所以可以规避此限制以编辑价格。

实现此目标的一种方法是保存HTML页面的源代码，编辑字段的值，将源代码重新加载到浏览器中，然后单击“购买”按钮。但是，一种更容易且更优雅的方法是使用拦截代理来即时修改所需数据。

拦截代理在攻击Web应用程序时非常有用，并且是您真正需要的唯一不可或缺的工具。有许多这样的工具可用。我们将使用Burp Suite，它是由本书的作者之一编写的。

代理位于您的Web浏览器和目标应用程序之间。它拦截发送到应用程序的每个请求以及接收到的每个响应，包括HTTP和HTTPS。它可以捕获任何拦截到的消息，以便用户进行检查或修改。如果您以前从未使用过拦截代理，则可以在第20章中阅读有关其功能以及如何对其进行配置和运行的更多信息。

安装并适当地配置拦截代理后，您可以拦截提交表单的请求并修改价格字段为任意值，如图5-2所示。

![](./img/101202.jpg)

图5-2：使用拦截代理修改隐藏表单字段的值

如果应用程序根据提交的价格处理交易，则可以以您选择的价格购买产品。

**提示:** 如果您发现一个应用程序以这种方式容易受到攻击，请查看您是否可以提交负数作为价格。在某些情况下，应用程序实际上接受了使用负价格的交易。攻击者收到退款到他的信用卡以及他订购的物品-如果曾经有过的话，这是一个双赢的局面。

## HTTP Cookie

通过客户端传输数据的另一种常用机制是HTTP Cookie。与隐藏的表单字段一样，通常这些不会显示在屏幕上，并且用户无法直接修改它们。当然，可以使用拦截代理通过更改设置它们的服务器响应或发出它们的后续客户端请求来修改它们。

考虑以下对先前示例的变体。在客户登录应用程序后，她会收到以下响应：

```http
HTTP/1.1 200 OK
Set-Cookie: DiscountAgreed=25
Content-Length: 1530
...
```

此DiscountAgreed cookie指向一个经典案例，该案例依赖于客户端控件（通常无法修改cookie）来保护通过客户端传输的数据。如果应用程序在将DiscountAgreed cookie提交回服务器时信任其值，则客户可以通过修改其值来获得任意折扣。例如：

```http
POST /shop/92/Shop.aspx?prod=3 HTTP/1.1
Host: mdsec.net
Cookie: DiscountAgreed=25
Content-Length: 10
quantity=1
```

## URL 参数

应用程序经常使用预设的URL参数通过客户端传输数据。例如，当用户浏览产品目录时，应用程序可能会为他提供指向以下 URL 的超链接：

http://mdsec.net/shop/?prod=3&pricecode=32

当包含参数的 URL 显示在浏览器的地址栏中时，任何用户都可以轻松地修改任何参数，而无需使用工具。但是，在许多情况下，应用程序可能期望普通用户无法查看或修改 URL 参数：

- 嵌入式图像使用包含参数的 URL 加载
- 包含参数的 URL 用于加载框架的内容
- 表单使用 POST 方法且其目标 URL 包含预设参数
- 应用程序使用弹出窗口或其他技术隐藏浏览器地址栏

当然，在任何此类情况下，URL 参数的值都可以使用之前讨论的拦截代理进行修改。

## Referer 标头

浏览器在大多数 HTTP 请求中都包含 Referer 标头。它用于指示当前请求的来源页面的 URL——可能是由于用户单击了超链接或提交了表单，也可能是因为页面引用了其他资源（如图像）。因此，它可以作为一种通过客户端传输数据的机制。由于应用程序处理的 URL 在其控制范围内，开发人员可能会认为 Referer 标头可以可靠地确定哪个 URL 生成了特定的请求。

例如，考虑一种允许用户在忘记密码时重置密码的机制。该应用程序要求用户按照规定的顺序完成几个步骤，然后才能使用以下请求实际重置密码的值：

```http
GET /auth/472/CreateUser.ashx HTTP/1.1
Host: mdsec.net
Referer: https://mdsec.net/auth/472/Admin.ashx
```

应用程序可能会使用 Referer 标头来验证此请求是否来自正确的阶段 (Admin.ashx)。如果是，用户就可以访问请求的功能。

然而，由于用户控制每个请求的各个方面，包括 HTTP 标头，因此可以通过直接访问 CreateUser.ashx 并使用截获代理将 Referer 标头的值更改为应用程序要求的值来轻松绕过此控制。

根据 w3.org 标准，Referer 标头是严格可选的。因此，虽然大多数浏览器都实现了它，但使用它来控制应用程序功能应该被视为一种“hack”（临时解决方案/非规范性做法）。

### 常见误解

人们常常认为 HTTP 标头比请求的其他部分（如 URL）更“防篡改”。这可能会导致开发人员在验证 URL 参数等其他数据时，同时信任在 Cookie 和 Referer 等标头中提交的值。然而，这种看法是错误的。鉴于有大量免费的拦截代理工具可用，任何针对应用程序的业余黑客都可以轻松更改所有请求数据。这就像认为当老师来搜查你的桌子时，把你的水枪藏在抽屉底部更安全，因为她需要弯下腰才能发现它。

### 渗透测试步骤

1. 在应用程序中找到所有使用隐藏表单字段、cookie 和 URL 参数通过客户端传输数据的实例。
2. 根据项目出现的位置和线索（如参数名称），尝试确定或猜测该项目在应用程序逻辑中的作用。
3. 以与项目在应用程序中的目的相关的方式修改项目的值。确定应用程序是否处理提交在参数中的任意值，以及这是否会使应用程序暴露于任何漏洞。

## 不透明数据

有时，通过客户端传输的数据不是透明地可理解的，因为它已经通过某种方式加密或混淆了。例如，您可能不会看到产品价格存储在隐藏字段中，而是看到传输了一个神秘的值：

```html
<form method=”post” action=”Shop.aspx?prod=4”>
Product: Nokia Infinity <br/>
Price: 699 <br/>
Quantity: <input type=”text” name=”quantity”> (Maximum quantity is 50)
<br/>
<input type=”hidden” name=”price” value=”699”>
<input type=”hidden” name=”pricing_token”
value=”E76D213D291B8F216D694A34383150265C989229”>
<input type=”submit” value=”Buy”>
</form>
```

当观察到这种情况时，您可以合理地推断，当提交表单时，服务器端应用程序会检查不透明字符串的完整性，甚至对其明文值进行解密或去混淆以执行一些处理。这种进一步的处理可能容易受到任何类型的错误的影响。然而，为了探查和利用这一点，首先需要以适当的方式包装您的有效载荷。

### 注意

通过客户端传输的不透明数据项通常是应用程序会话处理机制的一部分。在 HTTP cookie 中发送的会话令牌、在隐藏字段中传输的防 CSRF 令牌以及用于访问应用程序资源的一次性 URL 令牌都是客户端篡改的潜在目标。正如第 7 章中深入讨论的那样，这些类型的令牌有许多特定的注意事项。

### 渗透测试步骤

面对通过客户端传输的不透明数据，可以采用几种攻击途径：

1. 如果您知道不透明字符串背后的明文值，您可以尝试解密所使用的混淆算法。
2. 如第 4 章所述，应用程序可能包含其他您可以利用的功能，以返回由您控制的明文片段生成的不透明字符串。在这种情况下，您可能能够直接获取所需的字符串，以将任意有效载荷传递给您要攻击的函数。
3. 即使不透明字符串是不可穿透的，也可能在其他上下文中重放其值以达到恶意效果。例如，先前显示的表单中的 pricing_token 参数可能包含产品价格的加密版本。虽然无法为任意选择的任意价格生成加密等效项，但您可以从不同的、更便宜的产品中复制加密价格并将其提交到其位置。
4. 如果其他方法都失败了，您可以尝试攻击将解密或去混淆不透明字符串的服务器端逻辑，方法是提交其畸形变体——例如，包含过长的值、不同的字符集等。

### ASP.NET ViewState

通过客户端传输不透明数据的一种常见机制是 ASP.NET ViewState。这是一个在所有 ASP.NET Web 应用程序中默认创建的隐藏字段。它包含有关当前页面状态的序列化信息。ASP.NET 平台使用 ViewState 来提高服务器性能。它使服务器能够跨越连续的请求保留用户界面中的元素，而无需在服务器端维护所有相关状态信息。例如，服务器可能会根据用户提交的参数填充下拉列表。当用户发出后续请求时，浏览器不会将列表的内容提交回服务器。但是，浏览器会提交包含列表序列化形式的隐藏 ViewState 字段。服务器对 ViewState 进行反序列化并重新创建再次呈现给用户的相同列表。

除了 ViewState 的核心用途之外，开发人员还可以使用它跨越连续的请求存储任意信息。例如，应用程序可以将产品价格存储在 ViewState 中，而不是将其保存在隐藏的表单字段中，如下所示：

``` html
string price = getPrice(prodno);
ViewState.Add(“price”, price);
```

现在返回给用户的表单看起来像这样：

``` html
<form method=”post” action=”Shop.aspx?prod=3”>
<input type=”hidden” name=”__VIEWSTATE” id=”__VIEWSTATE”
value=”/wEPDwULLTE1ODcxNjkwNjIPFgIeBXByaWNlBQMzOTlkZA==” />
Product: HTC Avalanche <br/>
Price: 399 <br/>
Quantity: <input type=”text” name=”quantity”> (Maximum quantity is 50)
<br/>
<input type=”submit” value=”Buy”>
</form>
```

当用户提交表单时，她的浏览器发送以下内容：

```http
POST /shop/76/Shop.aspx?prod=3 HTTP/1.1
Host: mdsec.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 77
__VIEWSTATE=%2FwEPDwULLTE1ODcxNjkwNjIPFgIeBXByaWNlBQMzOTlkZA%3D%3D&
quantity=1
```

该请求显然不包含产品价格——只有订购数量和不透明的 ViewState 参数。随机更改该参数会导致错误消息，并且不会处理购买。

ViewState 参数实际上是一个 Base64 编码的字符串，可以轻松解码以查看放置在其中的价格参数：

```html
3D FF 01 0F 0F 05 0B 2D 31 35 38 37 31 36 39 30 ; =ÿ.....-15871690
36 32 0F 16 02 1E 05 70 72 69 63 65 05 03 33 39 ; 62.....price..39
39 64 64 ; 9dd
```

### 提示

当您尝试解码看似用 Base64 编码的字符串时，一个常见的错误是从字符串的错误位置开始解码。由于 Base64 编码的工作方式，如果您从错误的位置开始，解码后的字符串将包含乱码。Base64 是一种基于块的格式，其中每 4 个字节的编码数据会转换为 3 个字节的解码数据。因此，如果您尝试解码 Base64 字符串但没有发现任何有意义的内容，请尝试从编码字符串中的四个相邻偏移量开始解码。

默认情况下，ASP.NET 平台会通过向 ViewState 添加密钥哈希 (称为 MAC 保护) 来防止篡改。但是，一些应用程序会禁用此默认保护，这意味着您可以修改 ViewState 的值，以确定它是否会影响应用程序的服务器端处理。Burp Suite 包含一个 ViewState 解析器，用于指示 ViewState 是否受 MAC 保护，如图 5-3 所示。如果不受保护，您可以使用 ViewState 树下方的十六进制编辑器编辑 Burp 中的 ViewState 内容。当您将消息发送到服务器或客户端时，Burp 会发送您更新的 ViewState，并且在本例中，它使您可以更改所购买物品的价格。

![](./img/101203.jpg)

图 5-3：Burp Proxy 可以解码和呈现 ViewState，允许您查看其内容并在未设置 EnableViewStateMac 选项时编辑这些内容。

### 渗透测试步骤

1. 攻击 ASP.NET 应用程序时，请验证 ViewState 是否启用了 MAC 保护。这可以通过 ViewState 结构末尾是否存在 20 字节哈希来判断，您可以使用 Burp Suite 中的 ViewState 解析器确认是否存在哈希。
2. 即使 ViewState 受保护，也仍然可以使用 Burp 对应用程序的不同页面解码 ViewState，以发现应用程序是否正在通过客户端传输任何敏感数据。
3. 尝试修改 ViewState 中特定参数的值，同时不破坏其结构，看看是否会产生错误消息。
4. 如果您可以修改 ViewState 而不会导致错误，则应查看 ViewState 中每个参数的功能，并查看应用程序是否使用它存储任何自定义数据。尝试针对每个参数提交精心构造的值，以探测常见漏洞，就像您对通过客户端传输的任何其他数据项所做的那样。
5. 请注意，MAC 保护可以逐页启用或禁用，因此可能需要测试应用程序的每个重要页面是否存在 ViewState 漏洞。如果您启用了被动扫描的 Burp Scanner，Burp 会自动报告任何未启用 MAC 保护的 ViewState 页面。

## 捕获用户数据：HTML 表单

应用程序使用客户端控件来限制客户端提交的数据的另一种主要方式是使用未由服务器最初指定的、而是收集在客户端计算机本身上的数据。

HTML 表单是从用户那里捕获输入并将其提交到服务器的最简单、最常见的方法。通过这种方法的最基本用法，用户将数据输入到命名的文本字段中，这些字段将作为名称/值对提交到服务器。但是，表单也可以以其他方式使用；它们可以对用户提供的数据施加限制或执行验证检查。当应用程序使用这些客户端控件作为安全机制来防御恶意输入时，这些控件通常可以很容易地被绕过，从而使应用程序可能容易受到攻击。

### 限制长度

考虑以下原始 HTML 表单的变体，它对数量字段施加了 1 的最大长度：

```html
<form method=”post” action=”Shop.aspx?prod=1”>
Product: iPhone 5 <br/>
Price: 449 <br/>
Quantity: <input type=”text” name=”quantity” maxlength=”1”> <br/>
<input type=”hidden” name=”price” value=”449”>
<input type=”submit” value=”Buy”>
</form>
```

在这里，浏览器阻止用户在输入字段中输入超过一个字符，因此服务器端应用程序可能会假设它接收到的数量参数将小于 10。然而，这个限制可以通过拦截包含表单提交的请求来输入任意值，或者通过拦截包含表单的响应来删除 maxlength 属性，从而很容易地绕过。

### 拦截响应

当您尝试拦截和修改服务器响应时，您可能会发现代理中显示的相关消息如下所示：

```http
HTTP/1.1 304 Not Modified
Date: Wed, 6 Jul 2011 22:40:20 GMT
Etag: “6c7-5fcc0900”
Expires: Thu, 7 Jul 2011 00:40:20 GMT
Cache-Control: max-age=7200
```

此响应是因为浏览器已经拥有所请求资源的缓存副本。当浏览器请求缓存的资源时，它通常会向请求中添加两个标头——If-Modified-Since 和 If-None-Match：

```http
GET /scripts/validate.js HTTP/1.1
Host: wahh-app.com
If-Modified-Since: Sat, 7 Jul 2011 19:48:20 GMT
If-None-Match: “6c7-5fcc0900”
```

这些标头告诉服务器浏览器上次更新其缓存副本的时间。服务器提供的资源副本的 Etag 字符串是一种序列号，服务器为每个可缓存资源分配该序列号。每次修改资源时，它都会更新。如果服务器拥有的资源版本比 If-Modified-Since 标头中指定的日期新，或者当前版本的 Etag 与 If-None-Match 标头中指定的 Etag 相匹配，则服务器将使用最新版本的资源进行响应。否则，它将返回 304 响应，如这里所示，通知浏览器资源未被修改，浏览器应该使用其缓存副本。

当发生这种情况，并且您需要拦截和修改浏览器缓存的资源时，您可以拦截相关请求并删除 If-Modified-Since 和 If-None-Match 标头。这会导致服务器以完整版本的请求资源进行响应。Burp Proxy 包含一个选项，可以从每个请求中删除这些标头，从而覆盖浏览器发送的所有缓存信息。

##### 渗透步骤

1. 查找包含 maxlength 属性的表单元素。提交长度超过此长度但其他方面格式正确的数据（例如，如果应用程序期望一个数字，则该数据是数字）。
2. 如果应用程序接受过长的数据，您可以推断客户端验证没有在服务器上复制。
3. 根据应用程序对参数执行的后续处理，您可能能够利用验证中的缺陷来利用其他漏洞，例如 SQL 注入、跨站点脚本或缓冲区溢出。

### 基于脚本的验证

内置于 HTML 表单本身的输入验证机制非常简单，并且不足以对许多种类的输入执行相关验证。例如，用户注册表单可能包含姓名、电子邮件地址、电话号码和邮政编码字段，所有这些字段都期望不同类型的输入。因此，常见的是在脚本中实现自定义客户端输入验证。请考虑以下原始示例的变体：

```html
<form method=”post” action=”Shop.aspx?prod=2” onsubmit=”return
validateForm(this)”>
Product: Samsung Multiverse <br/>
Price: 399 <br/>
Quantity: <input type=”text” name=”quantity”> (Maximum quantity is 50)
<br/>
<input type=”submit” value=”Buy”>
</form>
<script>function validateForm(theForm)
{
var isInteger = /^\d+$/;
var valid = isInteger.test(quantity) &&
quantity > 0 && quantity <= 50;
if (!valid)
alert(’Please enter a valid quantity’);
return valid;
}
</script>
```

表单标签的 onsubmit 属性指示浏览器在用户单击提交按钮时执行 ValidateForm 函数，并且只有当该函数返回 true 时才提交表单。这种机制使客户端逻辑能够拦截试图提交表单的操作，对用户的输入执行自定义验证检查，并决定是否接受该输入。

在前面的示例中，验证很简单；它检查 amount 字段中输入的数据是否为整数，并且在 1 到 50 之间。

这种类型的客户端控件通常很容易绕过。通常，只需在浏览器中禁用 JavaScript 即可。如果这样做，onsubmit 属性将被忽略，并且表单将在没有任何自定义验证的情况下提交。

然而，如果应用程序依赖于客户端脚本进行正常操作（例如构建用户界面的部分），禁用 JavaScript 可能会破坏应用程序。一种更整洁的方法是在浏览器中输入一个良性的（已知良好的）值到输入字段中，使用您的代理拦截经过验证的提交，并将数据修改为您想要的值。这通常是最简单、最优雅的击败基于 JavaScript 的验证的方法。

或者，您可以拦截包含 JavaScript 验证例程的服务器的响应，并修改脚本以中和其效果——在前面的示例中，通过更改 ValidateForm 函数在每种情况下都返回 true。

##### 渗透步骤

1. 确定任何使用客户端 JavaScript 在表单提交之前执行输入验证的情况。
2. 提交服务器通常会阻止的数据，方法是修改提交请求以注入无效数据或修改表单验证代码以中和它。
3. 与长度限制一样，确定客户端控件是否在服务器上复制，如果没有，是否可以将其用于任何恶意目的。
4. 请注意，如果多个输入字段在表单提交之前受到客户端验证，则需要使用无效数据单独测试每个字段，同时在所有其他字段中保留有效值。如果您同时在多个字段中提交无效数据，则服务器可能会在识别第一个无效字段时停止处理表单。因此，您的测试无法到达应用程序中的所有可能代码路径。

#### 注意

在 Web 应用程序中，用于验证用户输入的客户端 JavaScript 例程很常见，但不要因此而得出结论认为每个这样的应用程序都是易受攻击的。只有当客户端验证没有在服务器上复制时，应用程序才会暴露，并且只有当绕过客户端验证的精心制作的输入可以用于导致应用程序的某些不良行为时，才会暴露。

在大多数情况下，对用户输入进行客户端验证对应用程序的性能和用户体验质量有有益的影响。例如，在填写详细的注册表单时，普通用户可能会犯各种错误，例如省略必填字段或错误地格式化他的电话号码。如果没有客户端验证，纠正这些错误可能需要多次重新加载页面和往返消息到服务器。在客户端实现基本验证检查可以使用户的体验更加流畅，并减少服务器上的负载。

### 禁用的元素

如果 HTML 表单上的元素被标记为 disabled，则它会显示在屏幕上，但通常是灰色的，并且不能像普通控件那样进行编辑或使用。此外，在提交表单时，它不会发送到服务器。例如，请考虑以下表单：

```html
<form method=”post” action=”Shop.aspx?prod=5”>
Product: Blackberry Rude <br/>
Price: <input type=”text” disabled=”true” name=”price” value=”299”>
<br/>
Quantity: <input type=”text” name=”quantity”> (Maximum quantity is 50)
<br/>
<input type=”submit” value=”Buy”>
</form>
```

这包括产品价格作为禁用的文本字段，并在屏幕上显示如图 5-4 所示。

![](./img/101204.jpg)

图 5-4：包含禁用输入字段的表单

当提交此表单时，只有 quantity 参数被发送到服务器。然而，禁用字段的存在表明应用程序可能最初使用了 price 参数，也许是在开发过程中用于测试。此参数将被提交到服务器，并且可能已被应用程序处理。在这种情况下，您应该绝对测试服务器端应用程序是否仍然处理此参数。如果这样做，请寻求利用这一事实。

#### 渗透测试步骤

1. 在应用程序的每个表单中查找禁用的元素。每当你找到一个，请尝试将其与表单的其他参数一起提交到服务器，以确定它是否有任何影响。
2. 通常，提交元素被标记为 disabled，以便按钮在相关操作不可用时显示为灰色。您应该始终尝试提交这些元素的名称，以确定应用程序是否在尝试执行请求的操作之前执行服务器端检查。
3. 请注意，当提交表单时，浏览器不包含禁用的表单元素。因此，如果您只是浏览应用程序的功能并监视浏览器发出的请求，您将无法识别这些元素。要识别禁用的元素，您需要监视服务器的响应或在浏览器中查看页面源代码。
4. 您可以使用 Burp Proxy 中的 HTML 修改功能来自动重新启用应用程序中使用的任何禁用的字段。

## 捕获用户数据：浏览器扩展组件

除了 HTML 表单之外，捕获、验证和提交用户数据的另一种主要方法是使用在浏览器扩展中运行的客户端组件，例如 Java 或 Flash。当首次在 Web 应用程序中使用时，浏览器扩展通常用于执行简单且通常是美观的任务。现在，公司越来越多地使用浏览器扩展来创建功能齐全的客户端组件。这些组件在浏览器中运行，跨多个客户端平台，并提供反馈、灵活性以及桌面应用程序的处理。

一个副作用是，以前会在服务器上进行的处理任务可能会由于速度和用户体验的原因而卸载到客户端。在某些情况下，例如在线交易应用程序，速度是如此关键，以至于大部分关键应用程序逻辑都在客户端进行。应用程序设计可能会故意牺牲安全性以换取速度，也许是错误地认为交易者是受信任的用户，或者浏览器扩展包含其自己的防御。回顾第 2 章和本章前面部分讨论的核心安全问题，我们知道，客户端组件防御其业务逻辑的概念是不可能的。

浏览器扩展可以通过各种方式捕获数据——通过输入表单，有时还通过与客户端操作系统的文件系统或注册表进行交互。它们可以在提交到服务器之前对捕获的数据执行任意复杂的验证和操作。此外，由于它们的内部工作比 HTML 表单和 JavaScript 更不透明，开发人员更有可能认为他们执行的验证无法绕过。因此，浏览器扩展通常是发现 Web 应用程序漏洞的一个富有成果的目标。

一个经典的浏览器扩展示例，该扩展在客户端应用控件，是一个赌场组件。考虑到我们对客户端控件易错性的观察，使用浏览器扩展（在潜在攻击者的机器上本地运行）来实现在线赌博应用程序的想法很有趣。如果游戏的任何方面都是在客户端而不是服务器上控制的，攻击者就可以精确地操纵游戏以提高赔率、更改规则或更改提交给服务器的分数。在这种情况下可能会发生几种类型的攻击：

- 客户端组件可以被信任来维护游戏状态。在这种情况下，对游戏状态进行本地篡改将为攻击者带来优势。
- 攻击者可以绕过客户端控件并执行旨在为自己提供游戏优势的非法操作。
- 攻击者可以找到一个隐藏的函数、参数或资源，当调用时，可以访问服务器端资源。
- 如果游戏涉及任何对等体或庄家，客户端组件可能会接收和处理有关其他玩家的信息，如果已知，这些信息可以用于攻击者的优势。

### 常见浏览器扩展组件技术

您最可能遇到的浏览器扩展技术是 Java applet、Flash 和 Silverlight。由于它们竞争实现相似的目标，因此它们的架构具有与安全相关的相似属性：

- 它们被编译为中间字节码。
- 它们在为执行提供沙箱环境的虚拟机中执行。
- 它们可以使用远程框架，使用序列化通过 HTTP 传输复杂的数据结构或对象。

#### Java

Java applet 在 Java 虚拟机 (JVM) 中运行，并受 Java 安全策略应用的沙箱限制。由于 Java 自 Web 历史的早期就存在，并且其核心概念相对保持不变，因此有大量知识和工具可用于攻击和防御 Java applet，如本章稍后所述。

#### Flash

Flash 对象在 Flash 虚拟机中运行，并且像 Java applet 一样，与主机计算机隔离。曾经主要作为一种提供动画内容的方法，Flash 已经发展了。随着较新版本的 ActionScript，Flash 现在明确地被标榜为能够交付完整的桌面应用程序。

Flash 的一个关键最新变化是 ActionScript 3 及其与 Action Message Format (AMF) 序列化的远程功能。

#### Silverlight

Silverlight 是 Microsoft 对 Flash 的替代品。它的设计目标类似于启用丰富的、类似桌面的应用程序，允许 Web 应用程序在沙箱环境中提供浏览器内的缩小版 .NET 体验。从技术上讲，Silverlight 应用程序可以用任何符合 .NET 的语言开发，从 C# 到 Python，尽管 C# 是迄今为止最常见的。

### 浏览器扩展组件攻击方法

在针对使用浏览器扩展组件的应用程序时，需要采用两种广泛的技术。

首先，您可以拦截并修改组件发出的请求以及从服务器接收的响应。在许多情况下，这是开始测试组件最快和最简单的方法，但您可能会遇到一些限制。传输的数据可能被混淆或加密，或者可能使用特定于所使用技术的方案进行序列化。仅通过查看组件生成的流量，您可能会忽略一些关键功能或业务逻辑，这些功能或业务逻辑只能通过分析组件本身来发现。此外，您可能会遇到使用拦截代理的正常方式的障碍；然而，通常可以通过一些仔细的配置来规避这些障碍，如本章后面所述。

其次，您可以直接针对组件本身，并尝试对其字节码进行反编译以查看原始源代码，或使用调试器与组件进行动态交互。这种方法的优点是，如果做得彻底，您可以识别组件支持或引用的所有功能。它还允许您修改提交给服务器的请求中的关键数据，而不管用于传输数据的任何混淆或加密机制。这种方法的一个缺点是它可能很耗时，并且可能需要对组件中使用的技术和编程语言有详细的了解。

在许多情况下，这两种技术的结合是合适的。以下各节将更详细地介绍每一种技术。

#### 拦截浏览器扩展的流量

如果您的浏览器已经配置为使用拦截代理，并且应用程序使用浏览器扩展加载客户端组件，您可能会看到来自该组件的请求通过您的代理。在某些情况下，您无需执行任何其他操作即可开始测试相关功能，因为您可以像往常一样拦截和修改组件的请求。

在绕过浏览器扩展中实现的客户端输入验证的上下文中，如果组件透明地将经过验证的数据提交给服务器，则可以使用拦截代理以与 HTML 表单数据相同的方式修改此数据。例如，支持身份验证机制的浏览器扩展可能会捕获用户凭据，对这些凭据进行一些验证，并将这些值作为请求中的明文参数提交给服务器。无需对组件本身进行任何分析或攻击即可轻松绕过验证。

在其他情况下，您可能会遇到各种阻碍您测试的障碍，如以下各节所述。

#### 处理序列化数据

应用程序可能会在 HTTP 请求中传输数据或对象之前对其进行序列化。虽然可以通过检查原始序列化数据来解密一些基于字符串的数据，但通常需要在完全理解序列化数据之前对其进行解包。如果您想修改数据以干扰应用程序的处理，首先需要解包序列化内容，根据需要对其进行编辑，然后正确地重新序列化。简单地编辑原始序列化数据几乎肯定会破坏格式，并在应用程序处理消息时导致解析错误。

每种浏览器扩展技术都有自己的序列化数据在 HTTP 消息中的方案。因此，通常可以根据所使用的客户端组件的类型推断序列化格式，但在任何情况下，通常可以通过仔细检查相关 HTTP 消息来确定格式。

##### Java 序列化

Java 语言包含对对象序列化的本机支持，Java 小程序可以使用它在客户端和服务器应用程序组件之间发送序列化数据结构。包含序列化 Java 对象的消息通常可以通过它们具有以下 Content-Type 头来识别：

```http
Content-Type: application/x-java-serialized-object
```

拦截原始序列化数据后，您可以使用 Java 本身对其进行反序列化，以访问其中包含的原始数据项。

DSer 是 Burp Suite 的一个方便的插件，它提供了一个框架来查看和操作在 Burp 中拦截的序列化 Java 对象。

此工具将拦截对象中的原始数据转换为 XML 格式，以便于编辑。

当您修改了相关数据后，DSer 将重新序列化对象并相应地更新 HTTP 请求。

您可以从以下 URL 下载 DSer 并了解有关其工作原理的更多信息：

[http://blog.andlabs.org/2010/09/re-visiting-java-de-serialization-it.html](http://blog.andlabs.org/2010/09/re-visiting-java-de-serialization-it.html)

##### Flash 序列化

Flash 使用其自己的序列化格式，可用于在服务器和客户端组件之间传输复杂的数据结构。Action Message Format (AMF) 通常可以通过以下 Content-Type 头来识别：

```http
Content-Type: application/x-amf
```

Burp 本机支持 AMF 格式。当它识别包含序列化 AMF 数据的 HTTP 请求或响应时，它会解包内容并以树形形式呈现，以便查看和编辑，如图 5-5 所示。当您修改了结构中的相关原始数据项时，Burp 会重新序列化消息，您可以将其转发到服务器或客户端进行处理。

![](./img/101205.jpg)

图 5-5：Burp Suite 支持 AMF 格式，并允许您查看和编辑反序列化数据

##### Silverlight 序列化

Silverlight 应用程序可以使用内置于 .NET 平台的 Windows Communication Foundation (WCF) 远程框架。使用 WCF 的 Silverlight 客户端组件通常使用 Microsoft 的 .NET Binary Format for SOAP (NBFS)，可以通过以下 Content-Type 头来识别：

```http
Content-Type: application/soap+msbin1
```

一款插件可用于 Burp Proxy，它会在 Burp 的拦截窗口中显示 NBFS 编码的数据之前自动将其反序列化。

在查看或编辑解码数据后，插件会在将数据转发到服务器或客户端进行处理之前对其进行重新编码。

WCF binary SOAP plug-in for Burp 由 Brian Holyfield 制作，可在此处下载：

[www.gdssecurity.com/l/b/2009/11/19/wcf-binary-soap-plug-in-for-burp](www.gdssecurity.com/l/b/2009/11/19/wcf-binary-soap-plug-in-for-burp/)

#### 拦截浏览器扩展流量的障碍

如果您已将浏览器设置为使用拦截代理，您可能会发现浏览器扩展组件发出的请求没有被您的代理拦截或失败。通常，这个问题是由于组件对 HTTP 代理或 SSL（或两者）的处理问题造成的。通常可以通过对工具进行一些仔细的配置来解决它。

第一个问题是客户端组件可能不遵守您在浏览器或计算机设置中指定的代理配置。这是因为组件可能会发出自己的 HTTP 请求，超出浏览器本身或扩展框架提供的 API。如果发生这种情况，您仍然可以拦截组件的请求。您需要修改计算机的 hosts 文件以实现拦截，并配置您的代理以支持隐形代理和自动重定向到正确的目标主机。有关如何执行此操作的更多详细信息，请参见第 20 章。

第二个问题是客户端组件可能不接受拦截代理所呈现的 SSL 证书。如果您的代理使用通用自签名证书，并且您已将浏览器配置为接受它，浏览器扩展组件可能仍会拒绝该证书。这可能是因为浏览器扩展没有获取浏览器临时信任证书的配置，或者可能是因为组件本身以编程方式要求不应接受不受信任的证书。

在任何一种情况下，您可以通过配置您的代理使用主 CA 证书来规避此问题，该证书用于为您访问的每个站点签署有效的每个主机证书，并在计算机的受信任证书存储中安装 CA 证书。有关如何执行此操作的更多详细信息，请参见第 20 章。

在某些罕见的情况下，您可能会发现客户端组件正在使用 HTTP 之外的协议进行通信，这根本无法使用拦截代理进行处理。在这些情况下，您仍然可以通过使用网络嗅探器或函数挂钩工具来查看和修改受影响的流量。

一个例子是 Echo Mirage，它可以注入到进程中并拦截对套接字 API 的调用，允许您在数据发送到网络之前查看和修改它。Echo Mirage 可以从以下 URL 下载：

[www.bindshell.net/tools/echomirage](www.bindshell.net/tools/echomirage)

#### 渗透步骤

1. **确保您的代理正确拦截来自浏览器扩展的所有流量。** 如果必要，请使用嗅探器识别任何未正确代理的流量。
2. **如果客户端组件使用标准序列化方案，请确保您拥有必要的工具来解包和修改它。** 如果组件使用专有编码或加密机制，您需要反编译或调试组件以进行全面测试。
3. **查看触发关键客户端逻辑的服务器响应。** 通常，及时拦截和修改服务器响应可能会允许您“解锁”客户端 GUI，从而轻松地揭示并执行复杂或多阶段的特权操作。
4. **如果应用程序执行任何关键逻辑或事件，客户端组件不应该被信任来执行（例如，在赌博应用程序中抽牌或掷骰子），请查找关键逻辑执行与与服务器通信之间的任何相关性。** 如果客户端不与服务器通信以确定事件的结果，则该应用程序绝对容易受到攻击。

#### 反编译浏览器扩展

迄今为止，攻击浏览器扩展组件的最彻底方法是反编译对象，对源代码进行全面审查，必要时修改代码以更改对象的行为，然后重新编译它。如前所述，浏览器扩展被编译成字节码。字节码是一种高级平台独立的二进制表示，可以由相关解释器（如 Java 虚拟机或 Flash Player）执行，每种浏览器扩展技术都使用自己的字节码格式。因此，应用程序可以在解释器本身可以运行的任何平台上运行。

字节码表示的高级性质意味着理论上总是可以将字节码反编译成类似于原始源代码的东西。然而，可以部署各种防御技术来导致反编译失败，或输出非常难以跟踪和解释的反编译代码。

在这些混淆防御的条件下，反编译字节码通常是理解和攻击浏览器扩展组件的首选途径。这允许您查看业务逻辑、评估客户端应用程序的完整功能，并以有针对性的方式修改其行为。

翻译至P140